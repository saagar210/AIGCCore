use crate::error::CoreResult;
use serde::Serialize;

use super::model::EvidenceItem;

#[derive(Debug, Clone, Serialize, PartialEq, Eq)]
pub struct MappingReviewRow {
    pub control_id: String,
    pub capability: String,
    pub control_family: String,
    pub status: String,
    pub mapped_artifact_ids: Vec<String>,
    pub reviewer_note: String,
}

pub fn render_evidence_index_csv(items: &[EvidenceItem]) -> CoreResult<String> {
    let mut rows = items.to_vec();
    rows.sort_by(|a, b| a.artifact_id.cmp(&b.artifact_id));

    let mut wtr = csv::WriterBuilder::new().from_writer(vec![]);
    wtr.write_record(&[
        "artifact_id",
        "artifact_sha256",
        "title",
        "tags",
        "control_families",
    ])?;
    for row in rows {
        wtr.write_record(&[
            row.artifact_id,
            row.artifact_sha256,
            row.title,
            row.tags.join(";"),
            row.control_family_labels.join(";"),
        ])?;
    }
    let bytes = wtr.into_inner().map_err(|e| e.into_error())?;
    Ok(String::from_utf8_lossy(&bytes).replace("\r\n", "\n"))
}

pub fn render_evidence_index_markdown(items: &[EvidenceItem]) -> String {
    let mut rows = items.to_vec();
    rows.sort_by(|a, b| a.artifact_id.cmp(&b.artifact_id));

    let mut out = Vec::new();
    out.push("# Evidence Index".to_string());
    out.push("".to_string());
    out.push("| Artifact ID | SHA-256 | Title | Tags | Control Families |".to_string());
    out.push("|---|---|---|---|---|".to_string());
    for row in rows {
        out.push(format!(
            "| {} | {} | {} | {} | {} |",
            row.artifact_id,
            row.artifact_sha256,
            row.title,
            row.tags.join(", "),
            row.control_family_labels.join(", ")
        ));
    }
    out.push("".to_string());
    out.join("\n")
}

pub fn render_evidence_index_pdf(items: &[EvidenceItem]) -> Vec<u8> {
    let mut rows = items.to_vec();
    rows.sort_by(|a, b| a.artifact_id.cmp(&b.artifact_id));

    let mut lines = vec![
        "Evidence Index".to_string(),
        "Generated by AIGC Core EvidenceOS".to_string(),
        String::new(),
    ];
    for row in rows {
        lines.push(format!(
            "{} | {} | {} | {}",
            row.artifact_id,
            row.title,
            row.tags.join(","),
            row.control_family_labels.join(",")
        ));
    }

    build_minimal_pdf(&lines)
}

fn build_minimal_pdf(lines: &[String]) -> Vec<u8> {
    let mut stream = String::new();
    stream.push_str("BT\n");
    stream.push_str("/F1 11 Tf\n");
    stream.push_str("50 760 Td\n");
    for (idx, line) in lines.iter().enumerate() {
        if idx > 0 {
            stream.push_str("0 -14 Td\n");
        }
        stream.push_str(&format!("({}) Tj\n", escape_pdf_text(line)));
    }
    stream.push_str("ET\n");
    let stream_bytes = stream.into_bytes();

    let obj1 = b"<< /Type /Catalog /Pages 2 0 R >>".to_vec();
    let obj2 = b"<< /Type /Pages /Kids [3 0 R] /Count 1 >>".to_vec();
    let obj3 = b"<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>".to_vec();
    let obj4 = {
        let mut v = Vec::new();
        v.extend_from_slice(format!("<< /Length {} >>\nstream\n", stream_bytes.len()).as_bytes());
        v.extend_from_slice(&stream_bytes);
        v.extend_from_slice(b"endstream");
        v
    };
    let obj5 = b"<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>".to_vec();

    let objects = [obj1, obj2, obj3, obj4, obj5];
    let mut out = Vec::new();
    out.extend_from_slice(b"%PDF-1.4\n");

    let mut offsets: Vec<usize> = vec![0];
    for (idx, obj) in objects.iter().enumerate() {
        offsets.push(out.len());
        out.extend_from_slice(format!("{} 0 obj\n", idx + 1).as_bytes());
        out.extend_from_slice(obj);
        out.extend_from_slice(b"\nendobj\n");
    }

    let xref_offset = out.len();
    out.extend_from_slice(format!("xref\n0 {}\n", offsets.len()).as_bytes());
    out.extend_from_slice(b"0000000000 65535 f \n");
    for off in offsets.iter().skip(1) {
        out.extend_from_slice(format!("{:010} 00000 n \n", off).as_bytes());
    }
    out.extend_from_slice(
        format!(
            "trailer\n<< /Size {} /Root 1 0 R >>\nstartxref\n{}\n%%EOF\n",
            offsets.len(),
            xref_offset
        )
        .as_bytes(),
    );
    out
}

fn escape_pdf_text(s: &str) -> String {
    let mut out = String::new();
    for c in s.chars() {
        match c {
            '\\' => out.push_str("\\\\"),
            '(' => out.push_str("\\("),
            ')' => out.push_str("\\)"),
            _ => out.push(c),
        }
    }
    out
}

pub fn render_missing_checklist_markdown(
    missing_control_ids: &[String],
    mapping_rows: &[MappingReviewRow],
) -> String {
    let mut out = Vec::new();
    out.push("# Missing Evidence Checklist".to_string());
    out.push("".to_string());
    if missing_control_ids.is_empty() {
        out.push("- [x] No missing control evidence mappings.".to_string());
        out.push("".to_string());
        return out.join("\n");
    }

    let mut sorted = missing_control_ids.to_vec();
    sorted.sort();
    sorted.dedup();
    for control_id in sorted {
        let title = mapping_rows
            .iter()
            .find(|row| row.control_id == control_id)
            .map(|row| format!("{} ({})", row.control_id, row.capability))
            .unwrap_or(control_id);
        out.push(format!("- [ ] {}", title));
    }
    out.push("".to_string());
    out.join("\n")
}
