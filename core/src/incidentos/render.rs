use super::model::IncidentOsOutputManifestV1;
use super::timeline::{IncidentTimeline, TimelineEvent};
use super::redaction::{RedactionEngine, RedactionProfile};
use crate::error::{CoreError, CoreResult};
use serde_json::json;

pub fn output_manifest() -> IncidentOsOutputManifestV1 {
    IncidentOsOutputManifestV1 {
        schema_version: "INCIDENTOS_OUTPUT_V1".to_string(),
        deliverable_paths: vec![
            "exports/incidentos/deliverables/customer_packet.md".to_string(),
            "exports/incidentos/deliverables/internal_packet.md".to_string(),
            "exports/incidentos/deliverables/timeline.csv".to_string(),
        ],
        attachment_paths: vec![
            "exports/incidentos/attachments/redactions_map.json".to_string(),
            "exports/incidentos/attachments/citations_map.json".to_string(),
        ],
    }
}

/// Render customer-facing packet with redaction applied
pub fn render_customer_packet(
    timeline: &IncidentTimeline,
    redaction_profile: RedactionProfile,
) -> CoreResult<String> {
    let mut packet = String::from("# Incident Timeline - Customer Summary\n\n");

    // Overview section
    packet.push_str("## Overview\n\n");
    packet.push_str(&format!(
        "- **Total Events:** {}\n",
        timeline.events.len()
    ));
    packet.push_str(&format!(
        "- **Timeline Duration:** {:.0}s\n",
        timeline.total_duration_ms / 1000
    ));
    packet.push_str(&format!(
        "- **Severity Summary:** {} HIGH, {} MEDIUM, {} LOW\n",
        timeline.high_severity_count,
        timeline.medium_severity_count,
        timeline.low_severity_count
    ));
    packet.push_str(&format!(
        "- **Redaction Profile:** {:?}\n\n",
        redaction_profile
    ));

    packet.push_str("## Redacted Timeline\n\n");

    // Process events with redaction
    for event in &timeline.events {
        let mut engine = RedactionEngine::new(redaction_profile);
        let redacted_text = &event.evidence_text;
        let (redacted, _records) = engine.redact(redacted_text);

        packet.push_str(&format!(
            "**{}** | {} | {}\n",
            event.timestamp_iso, event.source_system, event.severity
        ));
        packet.push_str(&format!("{} → {}\n", event.actor, event.action));
        packet.push_str(&format!("Resource: {}\n", event.affected_resource));
        packet.push_str(&format!("{}\n\n", redacted));
        packet.push_str(&format!(
            "<!-- CLAIM:C{} ANCHOR:{} -->\n\n",
            event.anchor_id, event.anchor_id
        ));
    }

    packet.push_str("---\n\n");
    packet.push_str("*Generated by AIGC Core Phase 5 IncidentOS Pack*\n");
    packet.push_str("*This customer packet has redactions applied per profile*\n");

    Ok(packet)
}

/// Render internal-facing packet with full details
pub fn render_internal_packet(timeline: &IncidentTimeline) -> CoreResult<String> {
    let mut packet = String::from("# Incident Timeline - Internal Analysis\n\n");

    // Overview section
    packet.push_str("## Overview\n\n");
    packet.push_str(&format!(
        "- **Total Events:** {}\n",
        timeline.events.len()
    ));
    packet.push_str(&format!(
        "- **Timeline Duration:** {:.0}s\n",
        timeline.total_duration_ms / 1000
    ));
    packet.push_str(&format!(
        "- **Severity Breakdown:** {} HIGH, {} MEDIUM, {} LOW\n",
        timeline.high_severity_count,
        timeline.medium_severity_count,
        timeline.low_severity_count
    ));
    packet.push_str(&format!("- **Timeline Hash:** {}\n\n", timeline.timeline_hash));

    packet.push_str("## Complete Timeline with Citations\n\n");

    // Process events without redaction
    for event in &timeline.events {
        packet.push_str(&format!(
            "**{}** | {} | {}\n",
            event.timestamp_iso, event.source_system, event.severity
        ));
        packet.push_str(&format!("{} → {}\n", event.actor, event.action));
        packet.push_str(&format!("Resource: {}\n", event.affected_resource));
        packet.push_str(&format!("Evidence: {}\n", event.evidence_text));
        packet.push_str(&format!(
            "<!-- CLAIM:C{} ANCHOR:{} -->\n\n",
            event.anchor_id, event.anchor_id
        ));
    }

    packet.push_str("---\n\n");
    packet.push_str("*Generated by AIGC Core Phase 5 IncidentOS Pack*\n");
    packet.push_str("*This internal packet contains full unredacted details*\n");

    Ok(packet)
}

/// Generate redactions map as JSON
pub fn render_redactions_map(
    timeline: &IncidentTimeline,
    redaction_profile: RedactionProfile,
) -> CoreResult<String> {
    let mut redactions = Vec::new();

    for event in &timeline.events {
        let mut engine = RedactionEngine::new(redaction_profile);
        let (_redacted, records) = engine.redact(&event.evidence_text);

        for record in records {
            redactions.push(json!({
                "event_id": event.anchor_id,
                "timestamp": event.timestamp_iso,
                "original_text": record.original_text,
                "reason": record.reason,
                "profile_rule": record.profile_rule,
            }));
        }
    }

    serde_json::to_string_pretty(&redactions)
        .map_err(|e| CoreError::InvalidInput(format!("Failed to serialize redactions map: {}", e)))
}

/// Generate citations map as JSON
pub fn render_citations_map(timeline: &IncidentTimeline) -> CoreResult<String> {
    let mut citations = Vec::new();

    for event in &timeline.events {
        citations.push(json!({
            "claim_id": format!("C{}", event.anchor_id),
            "anchor_id": event.anchor_id,
            "timestamp": event.timestamp_iso,
            "system": event.source_system,
            "action": event.action,
        }));
    }

    serde_json::to_string_pretty(&citations)
        .map_err(|e| CoreError::InvalidInput(format!("Failed to serialize citations map: {}", e)))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::incidentos::timeline::TimelineEvent;

    fn sample_timeline() -> IncidentTimeline {
        IncidentTimeline {
            timeline_id: "TL_001".to_string(),
            incident_id: "INC_001".to_string(),
            events: vec![
                TimelineEvent {
                    anchor_id: "INCIDENT_EVT_0001_abcd1234".to_string(),
                    timestamp_iso: "2026-02-12T10:15:30Z".to_string(),
                    timestamp_epoch_ms: 1000,
                    source_system: "web-server".to_string(),
                    actor: "user@example.com".to_string(),
                    action: "login_attempt".to_string(),
                    affected_resource: "auth-service".to_string(),
                    evidence_text: "User successfully authenticated".to_string(),
                    severity: "LOW".to_string(),
                },
                TimelineEvent {
                    anchor_id: "INCIDENT_EVT_0002_efgh5678".to_string(),
                    timestamp_iso: "2026-02-12T10:16:00Z".to_string(),
                    timestamp_epoch_ms: 2000,
                    source_system: "database".to_string(),
                    actor: "system".to_string(),
                    action: "critical_error".to_string(),
                    affected_resource: "users-table".to_string(),
                    evidence_text: "System breach detected on 192.168.1.1".to_string(),
                    severity: "HIGH".to_string(),
                },
            ],
            total_duration_ms: 1000,
            high_severity_count: 1,
            medium_severity_count: 0,
            low_severity_count: 1,
            timeline_hash: "abc123def456".to_string(),
        }
    }

    #[test]
    fn test_render_customer_packet() {
        let timeline = sample_timeline();
        let packet = render_customer_packet(&timeline, RedactionProfile::Basic).unwrap();

        assert!(packet.contains("Customer Summary"));
        assert!(packet.contains("Redacted Timeline"));
        assert!(packet.contains("<!-- CLAIM:C"));
        assert_eq!(packet.matches("<!-- CLAIM:C").count(), 2); // One per event
    }

    #[test]
    fn test_render_internal_packet() {
        let timeline = sample_timeline();
        let packet = render_internal_packet(&timeline).unwrap();

        assert!(packet.contains("Internal Analysis"));
        assert!(packet.contains("Complete Timeline"));
        assert!(packet.contains("<!-- CLAIM:C"));
        assert!(packet.contains("full unredacted details"));
    }

    #[test]
    fn test_render_redactions_map() {
        let timeline = sample_timeline();
        let map_json = render_redactions_map(&timeline, RedactionProfile::Basic).unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&map_json).unwrap();

        assert!(parsed.is_array());
    }

    #[test]
    fn test_render_citations_map() {
        let timeline = sample_timeline();
        let map_json = render_citations_map(&timeline).unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&map_json).unwrap();

        assert!(parsed.is_array());
        if let Some(arr) = parsed.as_array() {
            assert_eq!(arr.len(), 2);
        }
    }

    #[test]
    fn test_output_manifest() {
        let manifest = output_manifest();
        assert_eq!(manifest.schema_version, "INCIDENTOS_OUTPUT_V1");
        assert_eq!(manifest.deliverable_paths.len(), 3);
        assert_eq!(manifest.attachment_paths.len(), 2);
    }
}
