use super::model::FinanceOsOutputManifestV1;
use super::parser::FinancialStatement;
use super::exceptions::Exception;
use crate::error::{CoreError, CoreResult};
use serde_json::json;

pub fn output_manifest() -> FinanceOsOutputManifestV1 {
    FinanceOsOutputManifestV1 {
        schema_version: "FINANCEOS_OUTPUT_V1".to_string(),
        deliverable_paths: vec![
            "exports/financeos/deliverables/exceptions_audit.md".to_string(),
            "exports/financeos/deliverables/compliance_internal.md".to_string(),
            "exports/financeos/deliverables/exceptions.csv".to_string(),
        ],
        attachment_paths: vec![
            "exports/financeos/attachments/exceptions_map.json".to_string(),
            "exports/financeos/attachments/compliance_summary.json".to_string(),
        ],
    }
}

/// Render auditor-facing exceptions report
pub fn render_exceptions_audit(
    statement: &FinancialStatement,
    exceptions: &[Exception],
) -> CoreResult<String> {
    let mut report = String::from("# Financial Audit - Exceptions Report\n\n");

    report.push_str("## Executive Summary\n\n");
    report.push_str(&format!("- **Statement Period:** {} to {}\n", statement.period_start, statement.period_end));
    report.push_str(&format!("- **Total Transactions:** {}\n", statement.summary.transaction_count));
    report.push_str(&format!("- **Total Amount:** ${:.2}\n", statement.summary.total_amount));

    let high_count = exceptions.iter().filter(|e| e.severity == "HIGH").count();
    let medium_count = exceptions.iter().filter(|e| e.severity == "MEDIUM").count();
    let low_count = exceptions.iter().filter(|e| e.severity == "LOW").count();

    report.push_str(&format!(
        "- **Exceptions Found:** {} HIGH, {} MEDIUM, {} LOW\n\n",
        high_count, medium_count, low_count
    ));

    if exceptions.is_empty() {
        report.push_str("## Conclusion\n\nNo exceptions detected. Statement appears compliant.\n");
    } else {
        report.push_str("## Flagged Transactions\n\n");

        for exception in exceptions {
            report.push_str(&format!(
                "### [{}] {} on {}\n\n",
                exception.severity, exception.transaction_id, exception.date
            ));
            report.push_str(&format!("**Amount:** ${:.2}\n", exception.amount));
            report.push_str(&format!("**Rule:** {}\n", exception.rule_triggered));
            report.push_str(&format!("**Finding:** {}\n", exception.description));
            report.push_str(&format!("**Action Required:** {}\n\n", exception.recommended_action));
            report.push_str(&format!(
                "<!-- CLAIM:C{} ANCHOR:{} -->\n\n",
                exception.exception_id, exception.exception_id
            ));
        }
    }

    report.push_str("---\n\n");
    report.push_str("*Generated by AIGC Core Phase 6 FinanceOS Pack*\n");
    report.push_str("*This audit report contains exceptions for investigation*\n");

    Ok(report)
}

/// Render internal compliance report
pub fn render_compliance_internal(
    statement: &FinancialStatement,
    exceptions: &[Exception],
) -> CoreResult<String> {
    let mut report = String::from("# Financial Compliance - Internal Analysis\n\n");

    report.push_str("## Statement Overview\n\n");
    report.push_str(&format!("- **Statement ID:** {}\n", statement.statement_id));
    report.push_str(&format!("- **Period:** {} to {}\n", statement.period_start, statement.period_end));
    report.push_str(&format!("- **Transactions:** {}\n", statement.summary.transaction_count));
    report.push_str(&format!("- **Total Amount:** ${:.2}\n", statement.summary.total_amount));
    report.push_str(&format!("- **Accounts:** {}\n", statement.summary.accounts.join(", ")));
    report.push_str(&format!("- **Categories:** {}\n\n", statement.summary.categories.join(", ")));

    report.push_str("## Exception Analysis\n\n");

    if exceptions.is_empty() {
        report.push_str("**Status:** COMPLIANT - No exceptions detected\n\n");
    } else {
        let high = exceptions.iter().filter(|e| e.severity == "HIGH").count();
        let medium = exceptions.iter().filter(|e| e.severity == "MEDIUM").count();
        let low = exceptions.iter().filter(|e| e.severity == "LOW").count();

        report.push_str(&format!("**Status:** {} HIGH, {} MEDIUM, {} LOW exceptions\n\n", high, medium, low));

        report.push_str("### HIGH Severity Items\n\n");
        for exception in exceptions.iter().filter(|e| e.severity == "HIGH") {
            report.push_str(&format!("- **{}** on {} (${:.2})\n", exception.transaction_id, exception.date, exception.amount));
            report.push_str(&format!("  - Rule: {}\n", exception.rule_triggered));
            report.push_str(&format!("  - Finding: {}\n", exception.description));
            report.push_str(&format!(
                "  <!-- CLAIM:C{} ANCHOR:{} -->\n",
                exception.exception_id, exception.exception_id
            ));
        }

        if medium > 0 {
            report.push_str("\n### MEDIUM Severity Items\n\n");
            for exception in exceptions.iter().filter(|e| e.severity == "MEDIUM") {
                report.push_str(&format!("- **{}** on {}\n", exception.transaction_id, exception.date));
                report.push_str(&format!(
                    "  <!-- CLAIM:C{} ANCHOR:{} -->\n",
                    exception.exception_id, exception.exception_id
                ));
            }
        }

        if low > 0 {
            report.push_str("\n### LOW Severity Items\n\n");
            for exception in exceptions.iter().filter(|e| e.severity == "LOW") {
                report.push_str(&format!("- **{}** on {}\n", exception.transaction_id, exception.date));
                report.push_str(&format!(
                    "  <!-- CLAIM:C{} ANCHOR:{} -->\n",
                    exception.exception_id, exception.exception_id
                ));
            }
        }
    }

    report.push_str("\n---\n\n");
    report.push_str("*Generated by AIGC Core Phase 6 FinanceOS Pack*\n");
    report.push_str("*This compliance report contains full analysis for internal teams*\n");

    Ok(report)
}

/// Render exceptions as CSV
pub fn render_exceptions_csv(exceptions: &[Exception]) -> CoreResult<String> {
    let mut csv = String::from("transaction_id,date,amount,rule,severity,description\n");

    for exception in exceptions {
        let desc_csv = exception.description.replace('"', "\"\"");
        csv.push_str(&format!(
            "{},{},{:.2},{},{},{}\n",
            exception.transaction_id,
            exception.date,
            exception.amount,
            exception.rule_triggered,
            exception.severity,
            format!("\"{}\"", desc_csv)
        ));
    }

    Ok(csv)
}

/// Render exception map as JSON
pub fn render_exceptions_map(exceptions: &[Exception]) -> CoreResult<String> {
    let mut items = Vec::new();

    for exception in exceptions {
        items.push(json!({
            "exception_id": exception.exception_id,
            "transaction_id": exception.transaction_id,
            "date": exception.date,
            "amount": exception.amount,
            "rule_triggered": exception.rule_triggered,
            "severity": exception.severity,
            "recommended_action": exception.recommended_action,
        }));
    }

    serde_json::to_string_pretty(&items)
        .map_err(|e| CoreError::InvalidInput(format!("Failed to serialize exceptions: {}", e)))
}

/// Render compliance summary as JSON
pub fn render_compliance_summary(statement: &FinancialStatement, exceptions: &[Exception]) -> CoreResult<String> {
    let high_count = exceptions.iter().filter(|e| e.severity == "HIGH").count();
    let medium_count = exceptions.iter().filter(|e| e.severity == "MEDIUM").count();
    let low_count = exceptions.iter().filter(|e| e.severity == "LOW").count();

    let summary = json!({
        "statement_id": statement.statement_id,
        "period_start": statement.period_start,
        "period_end": statement.period_end,
        "transaction_count": statement.summary.transaction_count,
        "total_amount": statement.summary.total_amount,
        "exception_count": exceptions.len(),
        "exceptions_by_severity": {
            "HIGH": high_count,
            "MEDIUM": medium_count,
            "LOW": low_count,
        },
        "compliance_status": if high_count == 0 && medium_count == 0 {
            "COMPLIANT"
        } else {
            "REVIEW_REQUIRED"
        },
    });

    serde_json::to_string_pretty(&summary)
        .map_err(|e| CoreError::InvalidInput(format!("Failed to serialize summary: {}", e)))
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_data() -> (FinancialStatement, Vec<Exception>) {
        let statement = FinancialStatement {
            statement_id: "STMT_TEST".to_string(),
            period_start: "2026-01-01".to_string(),
            period_end: "2026-01-31".to_string(),
            transactions: vec![],
            summary: super::super::parser::StatementSummary {
                total_amount: 15000.0,
                transaction_count: 3,
                accounts: vec!["checking".to_string()],
                categories: vec!["salary".to_string()],
                date_range: ("2026-01-01".to_string(), "2026-01-31".to_string()),
            },
        };

        let exceptions = vec![
            Exception {
                exception_id: "EXC_001".to_string(),
                transaction_id: "TX_001".to_string(),
                date: "2026-01-05".to_string(),
                amount: 15000.0,
                rule_triggered: "THRESHOLD".to_string(),
                severity: "HIGH".to_string(),
                description: "Large transaction".to_string(),
                recommended_action: "Review".to_string(),
            },
        ];

        (statement, exceptions)
    }

    #[test]
    fn test_render_exceptions_audit() {
        let (stmt, exceptions) = sample_data();
        let report = render_exceptions_audit(&stmt, &exceptions).unwrap();

        assert!(report.contains("Financial Audit"));
        assert!(report.contains("Exceptions Report"));
        assert!(report.contains("<!-- CLAIM:C"));
    }

    #[test]
    fn test_render_compliance_internal() {
        let (stmt, exceptions) = sample_data();
        let report = render_compliance_internal(&stmt, &exceptions).unwrap();

        assert!(report.contains("Compliance"));
        assert!(report.contains("Internal Analysis"));
        assert!(report.contains("<!-- CLAIM:C"));
    }

    #[test]
    fn test_render_exceptions_csv() {
        let (_, exceptions) = sample_data();
        let csv = render_exceptions_csv(&exceptions).unwrap();

        assert!(csv.contains("transaction_id,date,amount"));
        assert!(csv.contains("TX_001"));
    }

    #[test]
    fn test_render_exceptions_map() {
        let (_, exceptions) = sample_data();
        let map_json = render_exceptions_map(&exceptions).unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&map_json).unwrap();

        assert!(parsed.is_array());
    }

    #[test]
    fn test_render_compliance_summary() {
        let (stmt, exceptions) = sample_data();
        let summary_json = render_compliance_summary(&stmt, &exceptions).unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&summary_json).unwrap();

        assert!(parsed.is_object());
        assert!(parsed.get("compliance_status").is_some());
    }
}
