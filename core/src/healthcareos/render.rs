use super::model::HealthcareOsOutputManifestV1;
use super::parser::ClinicalTranscript;
use super::consent::ConsentStatus;
use crate::error::{CoreError, CoreResult};
use serde_json::json;

pub fn output_manifest() -> HealthcareOsOutputManifestV1 {
    HealthcareOsOutputManifestV1 {
        schema_version: "HEALTHCAREOS_OUTPUT_V1".to_string(),
        deliverable_paths: vec![
            "exports/healthcareos/deliverables/draft_note.md".to_string(),
            "exports/healthcareos/deliverables/verification_checklist.md".to_string(),
        ],
        attachment_paths: vec![
            "exports/healthcareos/attachments/consent_record.json".to_string(),
            "exports/healthcareos/attachments/citations_map.json".to_string(),
            "exports/healthcareos/attachments/uncertainty_map.json".to_string(),
        ],
    }
}

/// Render clinical draft note with citations
pub fn render_draft_note(
    transcript: &ClinicalTranscript,
    consent_status: &ConsentStatus,
) -> CoreResult<String> {
    let mut note = String::from("# Clinical Draft Note\n\n");

    // Header with consent warning if needed
    note.push_str("## Patient Information\n\n");
    note.push_str(&format!("- **Patient ID:** {}\n", transcript.patient_id));
    note.push_str(&format!("- **Date:** {}\n", transcript.date));
    note.push_str(&format!("- **Provider:** {}\n", transcript.provider));
    note.push_str(&format!("- **Specialty:** {}\n", transcript.specialty));
    note.push_str(&format!("- **Confidence:** {:.0}%\n\n", transcript.confidence * 100.0));

    // Consent warning if expired
    if matches!(consent_status, ConsentStatus::Expired) {
        note.push_str("⚠️ **WARNING:** Patient consent has expired. Request renewal before finalization.\n\n");
    }

    // Clinical content with citations
    note.push_str("## Clinical Summary\n\n");
    note.push_str(&format!("{}\n\n", transcript.content));
    note.push_str(&format!(
        "<!-- CLAIM:C{} ANCHOR:{} -->\n\n",
        transcript.transcript_id, transcript.transcript_id
    ));

    note.push_str("## Verification Status\n\n");
    note.push_str("- [ ] Demographics verified\n");
    note.push_str("- [ ] Chief complaint captured\n");
    note.push_str("- [ ] Assessment accurate\n");
    note.push_str("- [ ] Plan documented\n\n");

    note.push_str("---\n\n");
    note.push_str("*Generated by AIGC Core Phase 7 HealthcareOS Pack*\n");
    note.push_str("*This draft requires provider review and signature*\n");

    Ok(note)
}

/// Render verification checklist
pub fn render_verification_checklist(transcript: &ClinicalTranscript) -> CoreResult<String> {
    let mut checklist = String::from("# Verification Checklist\n\n");

    checklist.push_str(&format!("**Patient:** {}\n", transcript.patient_id));
    checklist.push_str(&format!("**Date:** {}\n", transcript.date));
    checklist.push_str(&format!("**Provider:** {}\n\n", transcript.provider));

    checklist.push_str("## Required Verifications\n\n");

    checklist.push_str("### Demographics\n");
    checklist.push_str("- [ ] Patient name matches record\n");
    checklist.push_str("- [ ] DOB verified\n");
    checklist.push_str("- [ ] MRN confirmed\n\n");

    checklist.push_str("### Clinical Content\n");
    checklist.push_str("- [ ] Chief complaint documented\n");
    checklist.push_str("- [ ] History of present illness clear\n");
    checklist.push_str("- [ ] Physical exam findings documented\n");
    checklist.push_str("- [ ] Assessment reflects clinical thinking\n");
    checklist.push_str("- [ ] Plan is actionable\n\n");

    checklist.push_str("### Quality Checks\n");
    checklist.push_str("- [ ] No protected health info in free text\n");
    checklist.push_str("- [ ] Grammar and spelling acceptable\n");
    checklist.push_str("- [ ] Medical terminology accurate\n");
    checklist.push_str("- [ ] Clinical logic sound\n\n");

    checklist.push_str("### Sign-Off\n");
    checklist.push_str("- [ ] Provider reviewed draft\n");
    checklist.push_str("- [ ] Corrections applied\n");
    checklist.push_str("- [ ] Ready for signature\n\n");

    Ok(checklist)
}

/// Render uncertainty map
pub fn render_uncertainty_map(transcript: &ClinicalTranscript) -> CoreResult<String> {
    let mut uncertainty_items = Vec::new();

    // Identify segments with low confidence speech recognition
    if transcript.confidence < 0.95 {
        uncertainty_items.push(json!({
            "type": "speech_recognition",
            "confidence": transcript.confidence,
            "recommendation": "Verify medical terms against clinical context",
        }));
    }

    // Mark potential ambiguous clinical terms
    let ambiguous_terms = ["possible", "may have", "suspected", "rule out"];
    for term in &ambiguous_terms {
        if transcript.content.to_lowercase().contains(term) {
            uncertainty_items.push(json!({
                "type": "clinical_uncertainty",
                "term": term,
                "recommendation": "Clarify with provider before finalization",
            }));
        }
    }

    serde_json::to_string_pretty(&uncertainty_items)
        .map_err(|e| CoreError::InvalidInput(format!("Failed to serialize uncertainty map: {}", e)))
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_transcript() -> ClinicalTranscript {
        ClinicalTranscript {
            transcript_id: "CLINICAL_001".to_string(),
            patient_id: "PT-2026-001".to_string(),
            date: "2026-02-12".to_string(),
            provider: "Dr. Smith".to_string(),
            specialty: "Cardiology".to_string(),
            content: "Patient with possible heart murmur. EKG normal. Recommend echocardiogram.".to_string(),
            confidence: 0.95,
        }
    }

    #[test]
    fn test_render_draft_note() {
        let tx = sample_transcript();
        let note = render_draft_note(&tx, &ConsentStatus::Valid).unwrap();

        assert!(note.contains("Clinical Draft Note"));
        assert!(note.contains("PT-2026-001"));
        assert!(note.contains("<!-- CLAIM:C"));
        assert!(note.contains("Verification Status"));
    }

    #[test]
    fn test_draft_note_with_expired_consent() {
        let tx = sample_transcript();
        let note = render_draft_note(&tx, &ConsentStatus::Expired).unwrap();

        assert!(note.contains("WARNING"));
        assert!(note.contains("expired"));
    }

    #[test]
    fn test_render_verification_checklist() {
        let tx = sample_transcript();
        let checklist = render_verification_checklist(&tx).unwrap();

        assert!(checklist.contains("Verification Checklist"));
        assert!(checklist.contains("Demographics"));
        assert!(checklist.contains("Clinical Content"));
        assert!(checklist.contains("PT-2026-001"));
    }

    #[test]
    fn test_render_uncertainty_map() {
        let tx = sample_transcript();
        let map_json = render_uncertainty_map(&tx).unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&map_json).unwrap();

        assert!(parsed.is_array());
        let arr = parsed.as_array().unwrap();
        // Should have items for low confidence and uncertain terms
        assert!(arr.len() > 0);
    }
}
