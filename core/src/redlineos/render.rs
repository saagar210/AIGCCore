use super::model::{RedlineOsOutputManifestV1, RiskAssessment, SegmentedClause};
use crate::error::CoreResult;

pub fn output_manifest() -> RedlineOsOutputManifestV1 {
    RedlineOsOutputManifestV1 {
        schema_version: "REDLINEOS_OUTPUT_V1".to_string(),
        deliverable_paths: vec![
            "exports/redlineos/deliverables/risk_memo.md".to_string(),
            "exports/redlineos/deliverables/clause_map.csv".to_string(),
            "exports/redlineos/deliverables/redline_suggestions.md".to_string(),
        ],
        attachment_paths: vec![
            "exports/redlineos/attachments/citations_map.json".to_string(),
            "exports/redlineos/attachments/anchor_index.json".to_string(),
        ],
    }
}

/// Render risk memo markdown with citations enforced
pub fn render_risk_memo(
    assessments: &[RiskAssessment],
    _clauses: &[SegmentedClause],
) -> CoreResult<String> {
    let mut memo = String::from("# Risk Assessment Memo\n\n");
    memo.push_str("## Summary\n\n");

    let high_count = assessments.iter().filter(|a| a.risk_level == "HIGH").count();
    let medium_count = assessments.iter().filter(|a| a.risk_level == "MEDIUM").count();
    let low_count = assessments.iter().filter(|a| a.risk_level == "LOW").count();

    memo.push_str(&format!("- **HIGH Risk Clauses:** {}\n", high_count));
    memo.push_str(&format!("- **MEDIUM Risk Clauses:** {}\n", medium_count));
    memo.push_str(&format!("- **LOW Risk Clauses:** {}\n\n", low_count));

    memo.push_str("## Detailed Findings\n\n");

    for assessment in assessments {
        memo.push_str(&format!("### Clause: {} \n", assessment.anchor_id));
        memo.push_str(&format!("**Risk Level:** {}\n\n", assessment.risk_level));
        memo.push_str(&format!("**Advisory:** {}\n\n", assessment.advisory));

        // CRITICAL: Enforce citations with markers
        memo.push_str(&format!(
            "<!-- CLAIM:C{} ANCHOR:{} -->\n\n",
            assessment.anchor_id, assessment.anchor_id
        ));
    }

    memo.push_str("---\n\n");
    memo.push_str("*Generated by AIGC Core Phase 4 RedlineOS Pack*\n");
    memo.push_str("*Determinism: Enabled (reproducible outputs)*\n");

    Ok(memo)
}

/// Render clause map as CSV
pub fn render_clause_map_csv(
    assessments: &[RiskAssessment],
) -> CoreResult<String> {
    let mut csv = String::from("clause_id,risk_level,keywords,anchor_id\n");

    for assessment in assessments {
        let keywords = assessment.keywords_matched.join(";");
        csv.push_str(&format!(
            "{},{},{},{}\n",
            assessment.anchor_id, assessment.risk_level, keywords, assessment.anchor_id
        ));
    }

    Ok(csv)
}

/// Render redline suggestions markdown
pub fn render_redline_suggestions(
    assessments: &[RiskAssessment],
) -> CoreResult<String> {
    let mut suggestions = String::from("# Suggested Redlines\n\n");

    let high_risk: Vec<_> = assessments
        .iter()
        .filter(|a| a.risk_level == "HIGH")
        .collect();

    if high_risk.is_empty() {
        suggestions.push_str("No HIGH-risk clauses requiring redlines.\n");
    } else {
        suggestions.push_str(&format!("## {} HIGH-Risk Clauses Requiring Review\n\n", high_risk.len()));

        for assessment in high_risk {
            suggestions.push_str(&format!("### Clause: {}\n\n", assessment.anchor_id));
            suggestions.push_str(&format!("**Issue:** {}\n\n", assessment.advisory));
            suggestions.push_str("**Recommended Action:** Consult legal counsel for appropriate redlines.\n\n");
        }
    }

    Ok(suggestions)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_risk_memo_has_citations() {
        let assessment = RiskAssessment {
            anchor_id: "REDLINE_test_abc123_0".to_string(),
            risk_level: "HIGH".to_string(),
            keywords_matched: vec!["indemnify".to_string()],
            advisory: "High risk clause".to_string(),
            citations: vec![],
        };

        let memo = render_risk_memo(&[assessment], &[]).unwrap();
        assert!(memo.contains("<!-- CLAIM:C"));
        assert!(memo.contains("Risk Assessment Memo"));
    }

    #[test]
    fn test_clause_map_csv_format() {
        let assessment = RiskAssessment {
            anchor_id: "REDLINE_test_abc123_0".to_string(),
            risk_level: "HIGH".to_string(),
            keywords_matched: vec!["indemnify".to_string()],
            advisory: "Test".to_string(),
            citations: vec![],
        };

        let csv = render_clause_map_csv(&[assessment]).unwrap();
        assert!(csv.contains("clause_id,risk_level"));
        assert!(csv.contains("HIGH"));
    }
}
